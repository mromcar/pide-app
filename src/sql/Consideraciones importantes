Important Considerations between schema.prisma y database PostgreSQL

- CHECK Constraints: Prisma does not directly support SQL CHECK constraints (e.g., price >= 0 , quantity > 0 , responsible_role IN ('cook', 'waiter') ). You'll need to implement these validation rules in your application logic.
- Generated Columns: The item_total_price in order_items is a GENERATED ALWAYS AS column in your SQL. Prisma doesn't have direct support for this. The field will either be null when queried, or you'll need to calculate it in your application. Alternatively, you could use a database trigger if you want the database to manage it, but Prisma won't be aware of this generation automatically.
- Views ( menu_translated ): Prisma schema does not define database views. You should query the base tables and perform the necessary joins and transformations in your application code or use Prisma's raw query capabilities ( $queryRaw ) if you need to leverage the existing view.
- Triggers and Functions: SQL triggers ( trigger_set_timestamp , archive_product , archive_variant , update_order_total ) and functions are database-level objects and are not defined within the Prisma schema. They will continue to work as defined in your SQL script, but Prisma will not manage them.
- Timestamps: I've used @db.Timestamp() for timestamp fields. Depending on your PostgreSQL version and specific needs, you might want to use @db.Timestamp(6) for microsecond precision if it was intended in your SQL TIMESTAMP type (which often defaults to microsecond precision).
- Default updated_at : The SQL triggers trigger_set_timestamp_products and trigger_set_timestamp_variants handle updating the updated_at columns. Prisma also has its own @updatedAt directive. If you keep the database triggers, you might not need @updatedAt in Prisma for those specific models, or you could remove the triggers and let Prisma handle it. I've kept the @default(now()) for updated_at which sets it on creation, but the triggers would handle subsequent updates.
