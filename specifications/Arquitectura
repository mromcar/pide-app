 A[schema.prisma] --> B[Prisma Client]
    B --> C[Types/DTOs]
    C --> D[Zod Schemas]
    D --> E[Database Services]
    E --> F[API Routes]
    F --> G[Frontend Services]
    G --> H[React Components]


Database Schema Definition
prisma/
└── schema.prisma      # Database schema definition
Generated Types
node_modules/
└── .prisma/
    └── client/       # Auto-generated Prisma types
Type Definitions
src/types/
├── entities/         # Database entity types
│   ├── order.ts
│   ├── product.ts
│   └── ...
├── serialized/       # API response types
│   ├── order.ts
│   ├── product.ts
│   └── ...
└── dtos/            # Input/Request types
    ├── order.ts
    └── product.ts
Zod Schemas
src/schemas/
├── common.ts        # Shared validation rules
├── order.ts         # Order validation schemas
├── product.ts       # Product validation schemas
└── ...
Database Services
src/services/
├── order-service.ts  # Order CRUD operations
├── product-service.ts
└── ...
API Routes
src/
└── app/
    └── api/
        ├── orders/
        │   ├── route.ts                # /api/orders (GET, POST)
        │   └── [orderId]/
        │       └── route.ts            # /api/orders/:orderId (GET, PUT, DELETE)
        ├── products/
        │   ├── route.ts                # /api/products (GET, POST)
        │   └── [productId]/
        │       └── route.ts            # /api/products/:productId
        ├── employees/
        │   ├── route.ts                # /api/employees (GET, POST)
        │   └── [employeeId]/
        │       └── route.ts            # /api/employees/:employeeId
        ├── restaurants/
        │   ├── route.ts                # /api/restaurants (GET, POST)
        │   └── [restaurantId]/
        │       └── route.ts            # /api/restaurants/:restaurantId
        └── auth/
            └── [...nextauth]/route.ts  # Si usas NextAuth




Frontend Services
src/services/api/
├── order-api.ts     # API client functions
└── product-api.ts
Frontend Components
src/components/
└── order/
    ├── OrderForm.tsx
    ├── OrderList.tsx
    └── OrderDetail.tsx
Data Flow Example for Creating an Order:
Schema defines structure:
model Order {
  id Int @id @default(autoincrement())
  items OrderItem[]
  // ...other fields
}
Types reflect schema:
export interface CreateOrderDTO {
  items: CreateOrderItemDTO[]
  notes?: string
}
Validation schema:
export const createOrderSchema = z.object({
  items: z.array(orderItemSchema),
  notes: z.string().optional()
})
Database service:
export async function createOrder(data: CreateOrderDTO): Promise<Order> {
  return prisma.order.create({
    data: {
      items: { create: data.items },
      notes: data.notes
    }
  })
}
API Route:
export async function POST(request: Request) {
  const data = await request.json()
  const validatedData = createOrderSchema.parse(data)
  const order = await createOrder(validatedData)
  return Response.json({ order })
}
Frontend API service:
export async function submitOrder(orderData: CreateOrderDTO) {
  return fetch('/api/client/orders', {
    method: 'POST',
    body: JSON.stringify(orderData)
  }).then(res => res.json())
}
React Component:
export function OrderForm() {
  async function handleSubmit(data: CreateOrderDTO) {
    try {
      await submitOrder(data)
      // Show success message
    } catch (error) {
      // Handle error
    }
  }

  return <form onSubmit={handleSubmit}>...</form>
}


1 Schema Prisma → Tipos TypeScript
prisma/
├── schema.prisma       # Define el modelo de datos

Generated Types
node_modules/
└── .prisma/
    └── client/       # Auto-generated Prisma types



2 Tipos Personalizados y DTOs

src/types/
├── dtos/
    ├── allergen.ts
    └── category.ts
    └── establishment.ts
    ├── order.ts         # CreateOrderDTO, UpdateOrderDTO
    └── product.ts       # CreateProductDTO, UpdateProductDTO


├── entities/
│   ├── allergen.ts      # Allergen y AllergenTranslation
│   ├── category.ts      # Category y CategoryTranslation
│   ├── establishement.ts      # Category y CategoryTranslation
│   ├── order.ts       #  Order y OrderItem
│   ├── product.ts       # Product y ProductTranslation
│   ├── user.ts       # Product y ProductTranslation
├── serialized/
│   ├── category.ts      # SerializedCategory
│   └── order.ts         # SerializedOrder
│   ├── product.ts       # SerializedProduct

├── enums.ts             # UserRole, OrderStatus, etc.



 import { Prisma } from '@prisma/client'

// Tipos derivados de Prisma
export type Category = Prisma.CategoryGetPayload<{
  include: { /* ... */ }
}>

// Tipos serializados para el frontend
export interface SerializedCategory {
  // ...
}
3 Validación con Zod

src/schemas/
    ├── allergen.ts
    ├── category.ts
    ├── common.ts
    ├── order.ts
    ├── product.ts

import { z } from 'zod'
import { OrderStatus } from '@prisma/client'

export const CreateOrderSchema = z.object({
  establishment_id: z.number(),
  items: z.array(z.object({
    variant_id: z.number(),
    quantity: z.number().positive(),
    notes: z.string().optional()
  })),
  notes: z.string().optional()
})

4 Servicios de Base de Datos
src/services/
    ├── allergen-services.ts
    ├── category-services.ts
    ├── common-services.ts
    ├── order-services.ts
    ├── product-services.ts


import { prisma } from '@/lib/prisma'
import type { CreateOrderDTO } from '@/types/dtos'

export async function createOrder(data: CreateOrderDTO) {
  return await prisma.order.create({
    data: {
      // ...
    }
  })
}

5 API Routes
import { CreateOrderSchema } from '@/schemas/menu'
import { createOrder } from '@/services/menu-services'

export async function POST(request: Request) {
  const data = await request.json()
  const validatedData = CreateOrderSchema.parse(data)
  const order = await createOrder(validatedData)
  // ...
}

src/app/api/
├── auth/
│   └── [...nextauth]/
│       └── route.ts
├── menu/                           # Group menu-related endpoints
│   ├── categories/
│   │   ├── route.ts               # GET, POST categories
│   │   └── [categoryId]/
│   │       └── route.ts           # PUT, DELETE category
│   ├── products/
│   │   ├── route.ts
│   │   └── [productId]/
│   │       └── route.ts
│   ├── variants/
│   │   ├── route.ts
│   │   └── [variantId]/
│   │       └── route.ts
│   └── allergens/
│       ├── route.ts
│       └── [allergenId]/
│           └── route.ts
└── orders/                        # Group order-related endpoints
    ├── client/
    │   ├── route.ts              # POST new order
    │   └── [orderId]/
    │       └── route.ts          # GET order status
    └── employee/
        ├── route.ts              # GET all orders, filtered
        └── [orderId]/
            └── route.ts          # PATCH update status

src/
├── utils/
│   └── api-responses.ts           # API response utilities
├── middleware/
│   └── auth-middleware.ts         # Authentication middleware
└── app/
    └── api/
        ├── menu/
        │   └── categories/
        │       └── route.ts       # Categories API endpoints
        └── orders/
            └── employee/
                └── [orderId]/
                    └── route.ts   # Employee order endpoints


6 Frontend Services
import type { CreateOrderDTO } from '@/types/dtos'

export async function submitOrder(orderData: CreateOrderDTO) {
  const response = await fetch('/api/menu', {
    method: 'POST',
    body: JSON.stringify(orderData)
  })
  return response.json()
}

7 Componentes React
'use client'
import { submitOrder } from '@/services/api'
import type { CreateOrderDTO } from '@/types/dtos'

export function OrderForm() {
  async function handleSubmit(data: CreateOrderDTO) {
    await submitOrder(data)
  }
  // ...
}





Estructura de Tipos y Modelos:

src/types/
├── menu.ts            # Definiciones de tipos para todo el menú y entidades

API Routes (Backend)
src/app/api/
├── auth/
│   └── [...nextauth]/     # Configuración de autenticación
├── products/
│   └── route.ts           # API endpoints para productos
├── categories/
│   └── route.ts           # API endpoints para categorías
└── orders/
    └── route.ts           # API endpoints para pedidos

Componentes de la UI (Frontend)
src/app/restaurant/[id]/menu/components/
├── CategoryList.tsx       # Lista de categorías
├── ProductList.tsx        # Lista de productos
├── ProductModal.tsx       # Modal de detalles del producto
├── LanguageSelector.tsx   # Selector de idioma
├── OrderSummary.tsx       # Resumen del pedido
└── OrderHistory.tsx       # Historial de pedidos


Servicios y Utilidades
src/services/
└── menu-services.ts       # Servicios para interactuar con la API

src/utils/
├── serializers.ts         # Funciones para serializar datos
└── translations.ts        # Utilidades para traducciones

src/lib/
└── prisma.ts             # Configuración del cliente Prisma


Configuración y Base de Datos
prisma/
├── schema.prisma         # Esquema de la base de datos
└── seed.ts              # Datos iniciales

.env                     # Variables de entorno


Estilos
src/styles/
├── components.css       # Estilos de componentes
└── fonts.css           # Configuración de fuentes

src/app/
└── globals.css         # Estilos globales

Archivos de Configuración
package.json            # Dependencias y scripts
tailwind.config.js      # Configuración de Tailwind CSS
next.config.js         # Configuración de Next.js
tsconfig.json          # Configuración de TypeScript


Los archivos más importantes para el desarrollo diario son:

menu.ts para los tipos
Los componentes en components
menu-services.ts para la lógica de negocio
schema.prisma para la estructura de la base de datos


Recapitulando los archivos y su propósito:
src/lib/prisma.ts: (Ya existente y recomendado) Tu cliente de Prisma, configurado como un singleton para una gestión eficiente de la base de datos.
src/types/dtos.ts: (Nuevo) Donde defines la estructura de los datos que tu API espera recibir en las peticiones (CreateOrderDTO para crear pedidos, UpdateOrderStatusDTO para cambiar estados, etc.).
src/app/api/employees/orders/route.ts: (Modificado) Este GET es para que los empleados vean todos los pedidos de su establecimiento, con filtros opcionales por estado o tipo.
src/app/api/employees/orders/[orderId]/route.ts: (Nuevo) Este GET es para que los empleados vean los detalles de un pedido específico de su establecimiento.
src/app/api/client/orders/route.ts: (Nuevo) Este POST es para que los clientes puedan crear un nuevo pedido.

src/app/: Esta es la carpeta principal para las páginas de tu aplicación Next.js.


restaurant/[id]/order/page.tsx: Esto es perfecto para el cliente que escanea el QR. La ruta sería algo como /restaurant/123/order, donde 123 es el id del establecimiento. En esta página, el cliente podría ver el menú de ese restaurante específico y realizar su pedido. Es la experiencia principal para el cliente que viene del QR.
dashboard/orders/page.tsx: Esto es ideal para los empleados (camareros, cocineros, administradores de establecimiento). Sería su panel principal para ver y gestionar los pedidos. Aquí es donde usarían la API de employees/orders que hemos creado.
src/components/: Un lugar centralizado para tus componentes reutilizables.


order/: Agrupar los componentes relacionados con los pedidos aquí es muy lógico.
OrderForm.tsx: Podría ser el formulario que los clientes usan para seleccionar productos y enviar su pedido.
OrderList.tsx: Un componente para mostrar una lista de pedidos, utilizado tanto en el dashboard/orders (para empleados) como posiblemente en la página de un cliente para ver el estado de su pedido.
OrderFilters.tsx: Para que los empleados puedan filtrar pedidos por estado, tipo, etc.
src/services/: Una capa dedicada a interactuar con tus APIs de backend.


orderServices.ts: Esto es crucial. Aquí pondrías funciones que se encarguen de hacer las llamadas a tus endpoints de la API. Por ejemplo:
WorkspaceClientMenu(establishmentId: number, lang: string): Para obtener la carta de un restaurante.
createClientOrder(orderData: CreateOrderDTO): Para enviar un nuevo pedido desde el cliente.
WorkspaceEmployeeOrders(establishmentId: number, filters?: OrderFilters): Para que los empleados obtengan la lista de pedidos.
WorkspaceEmployeeOrderDetails(orderId: number): Para que los empleados vean un pedido específico.
updateOrderStatus(orderId: number, newStatus: UpdateOrderStatusDTO): Para que los empleados cambien el estado de un pedido. Mantener esta lógica en services hace que tus componentes de página (page.tsx) sean más limpios y se centren solo en la UI.
src/types/: Donde defines tus tipos TypeScript.


dtos.ts: Ya hemos hablado de este. Es donde viven tus DTOs para las peticiones y respuestas de la API.


¡Claro que sí! Con gusto te hago un resumen completo de los archivos clave que hemos creado y modificado, explicando su propósito y cómo encajan en tu aplicación.

Resumen de Archivos Clave
Aquí tienes un desglose de los archivos importantes y su función en tu proyecto:
1. src/types/dtos.ts (Modificado)
Función: Este archivo ahora contiene la definición de los esquemas de validación de datos usando la librería Zod. En lugar de solo tipos de TypeScript, tenemos objetos z.object() que describen la estructura y las reglas de tus datos para solicitudes de API.
Funcionamiento:
CreateOrderItemSchema: Define cómo debe lucir un ítem individual dentro de un pedido al crearlo.
CreateOrderSchema: Define la estructura completa de un nuevo pedido que un cliente enviaría a tu API.
UpdateOrderStatusSchema: Define la estructura de los datos para actualizar el estado de un pedido, usado por los empleados.
Zod y Tipado: De estos esquemas de Zod, se infieren automáticamente los tipos de TypeScript (ej. CreateOrderDTO), lo que te asegura que tus datos son válidos tanto en tiempo de ejecución (con Zod) como en tiempo de compilación (con TypeScript).
2. src/lib/prisma.ts (Existente - Mencionado)
Función: Este archivo es donde configuras e inicializas tu cliente Prisma. Es la conexión principal entre tu aplicación y la base de datos.
Funcionamiento: Exporta una instancia de PrismaClient que se utiliza en todas tus rutas de API para interactuar con la base de datos (realizar consultas, mutaciones, etc.).
3. src/app/api/auth/[...nextauth]/route.ts (Existente - Mencionado)
Función: Contiene la configuración de NextAuth.js para la autenticación en tu aplicación. Define proveedores de autenticación, callbacks de sesión, etc.
Funcionamiento: Esencial para proteger tus rutas de API de empleados y asegurar que solo los usuarios autorizados (con roles específicos como 'waiter', 'cook', 'establishment_admin') puedan acceder a ciertos recursos.
4. src/store/orderStore.ts (Nuevo - Si usas Zustand/similar)
Función: Si optaste por una solución de gestión de estado global como Zustand para el carrito de compra (como se sugirió), este archivo define tu store central.
Funcionamiento: Provee el estado del carrito (cartItems) y las acciones para manipularlo (addToCart, removeFromCart, clearCart, etc.) a cualquier componente que use el hook useOrderStore(), sin necesidad de Prop Drilling o un Context Provider manual.
5. Rutas de API en src/app/api/ (Modificadas)
src/app/api/client/orders/route.ts (Modificado POST)


Función: Es el endpoint al que los clientes envían sus nuevos pedidos.
Funcionamiento: Recibe una solicitud POST, valida su cuerpo utilizando el CreateOrderSchema de Zod. Si la validación es exitosa, crea el pedido y sus ítems asociados en la base de datos a través de Prisma y devuelve el pedido creado.
src/app/api/employees/orders/route.ts (Modificado GET)


Función: Es el endpoint para que los empleados consulten la lista de pedidos de su establecimiento.
Funcionamiento: Requiere autenticación de empleado. Permite filtrar pedidos por status y orderType mediante parámetros de URL. Realiza una consulta a la base de datos incluyendo detalles de ítems, productos, variantes, alérgenos y traducciones para el idioma especificado. Los datos Decimal de Prisma se serializan a number para la respuesta JSON.
src/app/api/employees/orders/[orderId]/route.ts (Modificado PATCH)


Función: Permite a los empleados actualizar el estado de un pedido específico.
Funcionamiento: Requiere autenticación de empleado y valida que el orderId sea válido y que el pedido pertenezca al establecimiento del empleado. El cuerpo de la solicitud se valida con UpdateOrderStatusSchema de Zod. Actualiza el estado del pedido en la base de datos y añade un registro al historial de estados, devolviendo el pedido actualizado.
6. Componentes React en src/components/order/ (Nuevos/Modificados)
src/components/order/OrderForm.tsx (Modificado)


Función: Es el formulario que usa el cliente para enviar su pedido.
Funcionamiento: Recopila el número de mesa, notas y el método de pago. Utiliza el useOrderStore (Zustand) para acceder a los ítems del carrito. Al enviar, llama a createClientOrder (tu servicio) y maneja los estados de carga, éxito y error.
src/components/order/OrderList.tsx (Nuevo)


Función: Muestra una lista de pedidos. Diseñado para el dashboard de empleados.
Funcionamiento: Recibe una array de orders como prop y renderiza un OrderCard para cada uno. También recibe una función onOrderUpdate que se usa para refrescar la lista después de que un pedido sea modificado.
src/components/order/OrderCard.tsx (Nuevo - Auxiliar)


Función: Muestra los detalles de un solo pedido en el dashboard de empleados y permite cambiar su estado.
Funcionamiento: Recibe un objeto order y onUpdate. Muestra información detallada del pedido, ítems, traducciones y un selector para que el empleado cambie el estado del pedido, llamando a updateOrderStatus de tus servicios.
src/components/order/OrderFilters.tsx (Nuevo)


Función: Provee controles de interfaz de usuario para filtrar los pedidos en el dashboard de empleados.
Funcionamiento: Permite filtrar por estado y tipo de pedido. Cuando los filtros cambian, llama a una función onFiltersChange (proporcionada por useOrders en la página del dashboard) para actualizar la lista de pedidos.
7. src/hooks/useOrders.ts (Nuevo)
Función: Un hook personalizado para la página del dashboard de empleados (OrdersPage.tsx) para gestionar la lógica de carga de pedidos.
Funcionamiento: Encapsula la lógica de WorkspaceEmployeeOrders (llamada a la API), maneja los estados de loading, error y orders. También gestiona los filtros que se aplican a la API y expone una función updateFilters para que OrderFilters pueda cambiar el estado de los filtros y recargar los pedidos.
8. src/services/orderServices.ts (Existente - Mencionado)
Función: Este archivo contendría las funciones del lado del cliente para interactuar con tus APIs de pedidos.
Funcionamiento: Aquí definirías funciones como createClientOrder(orderData) (que llamaría a POST /api/client/orders) y updateOrderStatus(orderId, statusData) (que llamaría a PATCH /api/employees/orders/[orderId]), y WorkspaceEmployeeOrders(establishmentId, filters) (que llamaría a GET /api/employees/orders).
¿Qué necesitaría para poder acceder al menú de un restaurante en concreto?
Para que un cliente (o cualquier usuario) pueda acceder al menú de un restaurante en concreto, necesitas:
Una ruta de página en el frontend:


Lo más común es tener una ruta dinámica como: src/app/restaurant/[id]/page.tsx o src/app/restaurant/[id]/menu/page.tsx.
El [id] en la ruta de Next.js te permitirá capturar el ID del restaurante de la URL (ej., /restaurant/123).
Un componente para mostrar el menú:


Necesitarías un componente que reciba el establishmentId (el ID del restaurante) y sea responsable de cargar y mostrar sus productos y categorías. Por ejemplo: src/components/product/ProductList.tsx.
Un servicio de API para obtener el menú:


Tendrías un endpoint de API (por ejemplo: src/app/api/client/menu/[establishmentId]/route.ts) que reciba el ID del restaurante y devuelva sus productos, variantes, alérgenos y traducciones. Este endpoint no necesitaría autenticación, ya que es para clientes públicos.
El servicio de frontend (src/services/productServices.ts) llamaría a este endpoint.
Lógica en la página para cargar el menú:


Dentro de src/app/restaurant/[id]/menu/page.tsx (o donde decidas mostrar el menú), usarías un hook de React (useEffect o un hook personalizado) para llamar a tu servicio de API y obtener los datos del menú basándote en el establishmentId de la URL.
En resumen, el flujo sería:
El usuario navega a /restaurant/123/menu.
La página src/app/restaurant/[id]/menu/page.tsx se renderiza.
Esta página extrae el id (123) de la URL.
Un hook en la página o en un componente hijo llama a WorkspaceMenu(123) (función en src/services/productServices.ts).
WorkspaceMenu hace una solicitud GET a /api/client/menu/123.
La API consulta la base de datos a través de Prisma y devuelve los datos del menú.
Los datos se muestran en el componente ProductList.

